"""
Copyright (C) 2014 Mattias Ugelvik

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
""".

Reverse := [
  """
  @ = List

  Return `List` in reverse order.
  """.
  Helper := [
    {List, Acc} := @.
    case List of
      #[]    -> Acc.
      {H, T} -> Helper {T, {H, Acc}}.
    end.
  ].
  Helper {@, #[]}.
].

Head := [
  """
  @ = List

  Return the first element of `List`.
  """.  {H, T} := @, H.
].

Tail := [
  """
  @ = List

  Return `List` without its first element.
  """.
  {H, T} := @, T.
].

Map := [
  """
  @ = {Func, List}

  Applies `Func` to every elemement of `List` are returns the result.
  """.
  {Func, List} := @.
  #[Func E | E <- List].
].

Foldl := [
  """
  @ = {Func, Acc, List}

  Fold to the left of `List`, starting with `Acc` as the initial value.

  Func is called with the argument `{Acc, Elem}`, where `Acc` us the accumulated answer
  and E`lem` is the current element of the list being folded.
  """.
  case @ of
    {F, Acc, #[]}    -> Acc.
    {F, Acc, {H, T}} -> Foldl {F, F {Acc, H}, T}.
  end.
].

Foldr := [
  """
  @ = {Func, Acc, List}

  Fold to the right of `List`, starting with `Acc` as the initial value.

  Func is called with the argument `{Acc, Elem}`, where `Acc` us the accumulated answer
  and `Elem` is the current element of the list being folded.
  """.
  case @ of
    {F, Acc, #[]}    -> Acc.
    {F, Acc, {H, T}} -> F {Foldr {F, Acc, T}, H}.
  end.
].

Length := [
  """
  @ = List

  Returns the length of `List`.
  """.
  Foldl {[{Acc, _} := @, Acc+1.], 0, @}.
].


Range := [
  """
  @ = {From, To}

  Returns a list of integers ranging from `From` (inclusive), to `To` (exclusive).
  """.
  {From, To} := @.
  Helper := [
    {N, Acc} := @.
    case N <= From of
      true  -> {N, Acc}.
      false -> Helper {N-1, {N, Acc}}.
    end.
  ].
  case To <= From of
    true  -> #[].
    false -> Helper {To-1, #[]}.
  end.
].

Nth := [
  """
  @ = {N, List}

  Returns the Nth element of `List`. The list must
  be long enough.
  """.
  {N, {H, T}} := @.
  case N <= 1 of
    true  -> H.
    false -> Nth {N-1, T}.
  end.
].

Random_Choice := [
  """
  @ = List

  Returns a random element of `List`.
  """.
  Nth {Builtins:Random_Range {1, Length @ + 1}
      , @}.
].

Concat := [
  """
  @ = {List1, List2}

  Concatenates two lists.
  """.
  {L1, L2} := @.
  Helper := [
    {Elems_Left, Result} := @.
    case Elems_Left of
      #[]    -> Result.
      {H, T} -> Helper {T, {H, Result}}.
    end.
  ].
  Helper {Reverse L1, L2}.
].

Any := [
  """
  @ = {Func, List}

  Returns `true` if any of the elements of `List` pass the predicate function `Func`.

  The return value of `Func` is passed into `Bools:Truthy` before checking if it
  is `true` or `false`.
  """.
  {Func, List} := @.
  case List of
    #[]    -> false.
    {H, T} ->
      case Bools:Truthy (Func H) of
        true  -> true.
        false -> Any {Func, T}.
      end.
  end.
].

All := [
  """
  @ = {Func, List}

  Returns `true` if all the elements of `List` pass the predicate function `Func`.

  The return value of `Func` is passed into `Bools:Truthy` before checking if it
  is `true` or `false`.
  """.
  {Func, List} := @.
  case List of
    #[]    -> true.
    {H, T} ->
      case Bools:Truthy (Func H) of
        false -> false.
        true  -> All {Func, T}.
      end.
  end.
].


And := [
  """
  @ = List

  Returns `true` if all of the elements of `List` are `true` according to
  `Bools:Truthy`, false otherwise.
  """.
  case @ of
    #[]    -> true.
    {H, T} ->
      case Bools:Truthy H of
        false -> false.
        true  -> And T.
      end.
  end.
].

Or := [
  """
  @ = List

  Returns `true` if any of the elements of `List` are `true` according to
  `Bools:Truthy`, false otherwise.
  """.
  case @ of
    #[]    -> false.
    {H, T} ->
      case Bools:Truthy H of
        true  -> true.
        false -> Or T.
      end.
  end.
].


Member := [
  """
  @ = {Val, List}

  Returns `true` if `Val` is a member of the `List`, false otherwise.
  """.
  {Val, List} := @.
  Any {[@ == Val.], List}.
].

Repeat := [
  """
  @ = {N, Elem}

  Return a list of `N` `Elem`s.
  """.
  {Times, Elem} := @.
  Helper := [
    {TimesLeft, Acc} := @.
    case TimesLeft <= 0 of
      true  -> Acc.
      false -> Helper {TimesLeft-1, {Elem, Acc}}.
    end.
  ].
  Helper {Times, #[]}.
].

Remove := [
  """
  @ = {Elem, List}

  Return a list with all elements that are equal to `Elem` removed.
  """.
  {Elem, List} := @.
  #[E | E <- List, E != Elem].
].

Filter := [
  """
  @ = {Func, List}

  Return a list only with elements that pass the predicate function `Func`.


  The return value of `Func` is passed into `Bools:Truthy` before checking if it
  is `true` or `false`.
  """.
  {F, List} := @.
  #[E | E <- List, Bools:Truthy(F E)].
].

Zip := [
  """
  @ = {List1, List2}

  Zip two lists together. Returns a list of tuples.
  """.
  {L1, L2} := @.
  Helper := [
    case @ of
      {nil, _, Acc}             -> Acc.
      {_, nil, Acc}             -> Acc.
      {{H1, T1}, {H2, T2}, Acc} -> Helper {T1, T2, {{H1, H2}, Acc}}.
    end.
  ].
  Reverse (Helper {L1, L2, #[]}).
].

Zipwith := [
  """
  @ = {Func, L1, L2}

  Zip two lists together using the function `Func`.

  `Func` is called with the argument `{Elem1, Elem2}`, where `Elem1`
  is an element from `L1`, and `Elem2` is the corresponding element
  from `L2`.
  """.
  {F, L1, L2} := @.
  Helper := [
    case @ of
      {nil, _, Acc}             -> Acc.
      {_, nil, Acc}             -> Acc.
      {{H1, T1}, {H2, T2}, Acc} -> Helper {T1, T2, {F {H1, H2}, Acc}}.
    end.
  ].
  Reverse (Helper {L1, L2, #[]}).].

Take := [
  """
  @ = {N, List}

  Return the first `N` elements of `List`.
  """.
  {N, List} := @.
  Helper := [
    case @ of
      {_, nil, Acc} -> Acc.
      {0, _,   Acc} -> Acc.
      {Left, {H, T}, Acc} ->
        Helper {Left-1, T, {H, Acc}}.
    end.
  ].
  case N > 0 of
    true  -> Reverse (Helper {N, List, nil}).
    false -> #[].
  end.
].

Drop := [
  """
  @ = {N, List}.

  Drop the first `N` element off of `List`, and return the resulting list.
  """.
  case @ of
    {_, #[]}    -> #[].
    {0, List}   -> List.
    {N, {H, T}} -> Drop {N-1, T}.
  end.
].


Takewhile := [
  """
  @ = {Func, List}

  Takes elements from `List` as long as they pass the predicate
  function `Func`, and returns the resulting list.

  It stops taking elements as soon as an element doesn't pass the
  predicate function `Func`.

  The return value of `Func` is passed into `Bools:Truthy` before checking if it
  is `true` or `false`.
  """.
  {F, List} := @.
  Helper := [
    case @ of
      {nil,    Acc} -> Acc.
      {{H, T}, Acc} ->
        case Bools:Truthy (F H) of
          true  -> Helper {T, {H, Acc}}.
          false -> Acc.
        end.
    end.
  ].
  Reverse (Helper {List, nil}).
].

Dropwhile :=  [
  """
  @ = {Func, List}

  Drops elements from `List` as long as they pass the predicate
  function `Func`, and returns the resulting list.

  It stops dropping elements as soon as an element doesn't pass the
  predicate function `Func`.

  The return value of `Func` is passed into `Bools:Truthy` before checking if it
  is `true` or `false`.
  """.
  case @ of
    {_, #[]}    -> #[].
    {F, {H, T}} ->
      case Bools:Truthy (F H) of
        true  -> Dropwhile {F, T}.
        false -> {H, T}.
      end.
  end.
].