"""
Copyright (C) 2014 Mattias Ugelvik

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
""".

Joinwith :=  [
  """
  @ = {Str, List}

  Return a str which is the string representation of all the elements of `List`
  separated by `Str` concatenated.
  """.
  {Str, List} := @.
  Helper := [
    {Current, Acc} := @.
    case Current of
      #[]    -> Acc.
      {H, T} -> Helper {T, Acc + Str + ToStr H}.
    end.
  ].
  case List of
    #[]    -> "".
    {H, T} -> Helper {T, ToStr H}.
  end.
].

Join :=  [
  """
  @ = List

  Return a str which is the string representation of all the elements of `List`
  concatenated.
  """.
  Joinwith {"", @}.
].


ListToStr := [
  """
  @ = List

  Return the string representation for `List`.
  """.
  "#[" + Joinwith {", ", @} + "]".
].

Reverse := [
  """
  @ = List

  Return `List` in reverse order.
  """.
  Helper := [
    {List, Acc} := @.
    case List of
      #[]    -> Acc.
      {H, T} -> Helper {T, {H, Acc}}.
    end.
  ].
  Helper {@, #[]}.
].


Map := [
  """
  @ = {Func, List}

  Applies `Func` to every elemement of `List` are returns the result.
  """.
  {Func, List} := @.
  #[Func E | E <- List].
].

Foldl := [
  """
  @ = {Func, Acc, List}

  Fold from left to right of `List`, starting with `Acc` as the initial value.

  Func is called with the argument `{Acc, Elem}`, where `Acc` us the accumulated answer
  and E`lem` is the current element of the list being folded.
  """.
  case @ of
    {F, Acc, #[]}    -> Acc.
    {F, Acc, {H, T}} -> Foldl {F, F {Acc, H}, T}.
  end.
].

Foldr := [
  """
  @ = {Func, Acc, List}

  Fold from right to left of `List`, starting with `Acc` as the initial value.

  Func is called with the argument `{Acc, Elem}`, where `Acc` us the accumulated answer
  and `Elem` is the current element of the list being folded.
  """.
  case @ of
    {F, Acc, #[]}    -> Acc.
    {F, Acc, {H, T}} -> F {Foldr {F, Acc, T}, H}.
  end.
].

Length := [
  """
  @ = List

  Returns the length of `List`.
  """.
  Foldl {[{Acc, _} := @, Acc+1.], 0, @}.
].


Range := [
  """
  @ = {From, To}

  Returns a list of integers ranging from `From` (inclusive), to `To` (exclusive).
  """.
  {From, To} := @.
  Helper := [
    {N, Acc} := @.
    case N <= From of
      yeah -> {N, Acc}.
      nope -> Helper {N-1, {N, Acc}}.
    end.
  ].
  case To <= From of
    yeah -> #[].
    nope -> Helper {To-1, #[]}.
  end.
].

Nth := [
  """
  @ = {N, List}

  Returns the Nth element of `List`. The list must
  be long enough.
  """.
  {N, {H, T}} := @.
  case N <= 1 of
    yeah -> H.
    nope -> Nth {N-1, T}.
  end.
].

Random_Choice := [
  """
  @ = List

  Returns a random element of `List`.
  """.
  Nth {Builtins:Random_Range {1, Length @ + 1}
      , @}.
].

Concat := [
  """
  @ = {List1, List2}

  Concatenates two lists.
  """.
  {L1, L2} := @.
  Helper := [
    {Elems_Left, Result} := @.
    case Elems_Left of
      #[]    -> Result.
      {H, T} -> Helper {T, {H, Result}}.
    end.
  ].
  Helper {Reverse L1, L2}.
].

Any := [
  """
  @ = {Func, List}

  Returns `yeah` if any of the elements of `List` pass the predicate function `Func`.

  The return value of `Func` is passed into `Bools:Truthy` before checking if it
  is `yeah` or `nope`.
  """.
  {Func, List} := @.
  case List of
    #[]    -> nope.
    {H, T} ->
      case Bools:Truthy (Func H) of
        yeah -> yeah.
        nope -> Any {Func, T}.
      end.
  end.
].

All := [
  """
  @ = {Func, List}

  Returns `yeah` if all the elements of `List` pass the predicate function `Func`.

  The return value of `Func` is passed into `Bools:Truthy` before checking if it
  is `yeah` or `nope`.
  """.
  {Func, List} := @.
  case List of
    #[]    -> yeah.
    {H, T} ->
      case Bools:Truthy (Func H) of
        nope -> nope.
        yeah -> All {Func, T}.
      end.
  end.
].


And := [
  """
  @ = List

  Returns `yeah` if all of the elements of `List` are `yeah` according to
  `Bools:Truthy`, `nope` otherwise.
  """.
  case @ of
    #[]    -> yeah.
    {H, T} ->
      case Bools:Truthy H of
        nope -> nope.
        yeah -> And T.
      end.
  end.
].

Or := [
  """
  @ = List

  Returns `yeah` if any of the elements of `List` are `yeah` according to
  `Bools:Truthy`, `nope` otherwise.
  """.
  case @ of
    #[]    -> nope.
    {H, T} ->
      case Bools:Truthy H of
        yeah -> yeah.
        nope -> Or T.
      end.
  end.
].


Member := [
  """
  @ = {Val, List}

  Returns `yeah` if `Val` is a member of the `List`, `nope` otherwise.
  """.
  {Val, List} := @.
  Any {[@ == Val.], List}.
].

Repeat := [
  """
  @ = {N, Elem}

  Return a list of `N` `Elem`s.
  """.
  {Times, Elem} := @.
  Helper := [
    {TimesLeft, Acc} := @.
    case TimesLeft <= 0 of
      yeah -> Acc.
      nope -> Helper {TimesLeft-1, {Elem, Acc}}.
    end.
  ].
  Helper {Times, #[]}.
].

Remove := [
  """
  @ = {Elem, List}

  Return a list with all elements that are equal to `Elem` removed.
  """.
  {Elem, List} := @.
  #[E | E <- List, E != Elem].
].

Filter := [
  """
  @ = {Func, List}

  Return a list only with elements that pass the predicate function `Func`.


  The return value of `Func` is passed into `Bools:Truthy` before checking if it
  is `yeah` or `nope`.
  """.
  {F, List} := @.
  #[E | E <- List, Bools:Truthy(F E)].
].

Separate := [
  """
  @ = {Func, List}.

  Returns a tuble of the form `{TrueBucket, FalseBucket}` where `TrueBucket`
  are a list of elements from `List` that are truthy according to `Func`, and
  where `FalseBucket` are a list of elements from `List` that are falsy according
  to `Func`.
  
  The elements of the bucket have no guaranteed ordering.
  """.
  {Func, List} := @.
  Helper := [
    case @ of
      {nil, TrueBucket, FalseBucket} -> {TrueBucket, FalseBucket}.
      {{H, T}, TrueBucket, FalseBucket} ->
        case Bools:Truthy (Func H) of
          yeah -> Helper {T, {H, TrueBucket}, FalseBucket}.
          nope -> Helper {T, TrueBucket, {H, FalseBucket}}.
        end.
    end.
  ].

  Helper {List, nil, nil}.
].

Zip := [
  """
  @ = {List1, List2}

  Zip two lists together. Returns a list of tuples.
  """.
  {L1, L2} := @.
  Helper := [
    case @ of
      {nil, _, Acc}             -> Acc.
      {_, nil, Acc}             -> Acc.
      {{H1, T1}, {H2, T2}, Acc} -> Helper {T1, T2, {{H1, H2}, Acc}}.
    end.
  ].
  Reverse (Helper {L1, L2, #[]}).
].

Zipwith := [
  """
  @ = {Func, L1, L2}

  Zip two lists together using the function `Func`.

  `Func` is called with the argument `{Elem1, Elem2}`, where `Elem1`
  is an element from `L1`, and `Elem2` is the corresponding element
  from `L2`.
  """.
  {F, L1, L2} := @.
  Helper := [
    case @ of
      {nil, _, Acc}             -> Acc.
      {_, nil, Acc}             -> Acc.
      {{H1, T1}, {H2, T2}, Acc} -> Helper {T1, T2, {F {H1, H2}, Acc}}.
    end.
  ].
  Reverse (Helper {L1, L2, #[]}).].

Partition_At := [
  """
  {N, List} := @

  Return a tuple of the form `{Seen, Unseen}`
  where `Seen` are elements before and including the `N`th element
  of `List`, and `Unseen` are the rest. `Seen` IS REVERSED. The reason
  `Seen` is reversed is that I want to implement other functions in terms
  of this function, and don't want unnecessary overhead.
  """.
  {N, List} := @.
  Helper := [
    case @ of
      {_, nil,    Seen}    -> {Seen,    nil}.
      {0, Unseen, Seen}    -> {Seen, Unseen}.
      {Left, {H, T}, Seen} ->
        Helper {Left-1, T, {H, Seen}}.
    end.
  ].
  case N > 0 of
    yeah -> Helper {N, List, nil}.
    nope -> {#[], List}.
  end.
].

Take := [
  """
  @ = {N, List}

  Return the first `N` elements of `List`.
  """.
  Reverse (Car (Partition_At @)).
].

Drop := [
  """
  @ = {N, List}

  Drop the first `N` element off of `List`, and return the resulting list.
  """.
  Cdr (Partition_At @).
].


Takewhile := [
  """
  @ = {Func, List}

  Takes elements from `List` as long as they pass the predicate
  function `Func`, and returns the resulting list.

  It stops taking elements as soon as an element doesn't pass the
  predicate function `Func`.

  The return value of `Func` is passed into `Bools:Truthy` before checking if it
  is `yeah` or `nope`.
  """.
  {F, List} := @.
  Helper := [
    case @ of
      {nil,    Acc} -> Acc.
      {{H, T}, Acc} ->
        case Bools:Truthy (F H) of
          yeah -> Helper {T, {H, Acc}}.
          nope -> Acc.
        end.
    end.
  ].
  Reverse (Helper {List, nil}).
].

Dropwhile :=  [
  """
  @ = {Func, List}

  Drops elements from `List` as long as they pass the predicate
  function `Func`, and returns the resulting list.

  It stops dropping elements as soon as an element doesn't pass the
  predicate function `Func`.

  The return value of `Func` is passed into `Bools:Truthy` before checking if it
  is `yeah` or `nope`.
  """.
  case @ of
    {_, #[]}    -> #[].
    {F, {H, T}} ->
      case Bools:Truthy (F H) of
        yeah -> Dropwhile {F, T}.
        nope -> {H, T}.
      end.
  end.
].


ToTuple := [
  """
  @ = List

  Convert `List` into a tuple
  """.
  
  Helper := [
    case @ of
      {#[],    Acc} -> Acc.
      {{H, T}, Acc} -> Helper {T, Acc + {H}}.
    end.
  ].

  Helper {@, {}}.
].