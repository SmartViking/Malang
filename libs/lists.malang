"
Copyright (C) 2014 Mattias Ugelvik

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
".

Joinwith :=  [
  "
  @ = {Str, List}

  Return a str which is the string representation of all the elements of `List`
  separated by `Str` concatenated.
  ".
  {Str, List} := @.
  Helper := [
    {Current, Acc} := @.
    case Current of
      #[]    -> Acc.
      {H, T} -> Helper {T, Acc + Str + ToStr H}.
    end.
  ].
  case List of
    #[]    -> "".
    {H, T} -> Helper {T, ToStr H}.
  end.
].

Join :=  [
  "
  @ = List

  Return a str which is the string representation of all the elements of `List`
  concatenated.
  ".
  Joinwith {"", @}.
].


ListToStr := [
  "
  @ = List

  Return the string representation for `List`.
  ".
  Repr_Strings := Map {[
    case TypeOf @ of
      "str" -> Strings:Repr @.
      _     -> @.
    end. ], @}.
  "#[" + Joinwith {", ", Repr_Strings} + "]".
].

Reverse := [
  "
  @ = List

  Return `List` in reverse order.
  ".
  Helper := [
    {List, Acc} := @.
    case List of
      #[]    -> Acc.
      {H, T} -> Helper {T, {H, Acc}}.
    end.
  ].
  Helper {@, #[]}.
].


Map := [
  "
  @ = {Func, List}

  Applies `Func` to every elemement of `List` are returns the result.
  ".
  {Func, List} := @.
  #[Func E | E <- List].
].

Foldl := [
  "
  @ = {Func, Acc, List}

  Fold from left to right of `List`, starting with `Acc` as the initial value.

  Func is called with the argument `{Acc, Elem}`, where `Acc` us the accumulated answer
  and E`lem` is the current element of the list being folded.
  ".
  case @ of
    {F, Acc, #[]}    -> Acc.
    {F, Acc, {H, T}} -> Foldl {F, F {Acc, H}, T}.
  end.
].

Foldr := [
  "
  @ = {Func, Acc, List}

  Fold from right to left of `List`, starting with `Acc` as the initial value.

  Func is called with the argument `{Acc, Elem}`, where `Acc` us the accumulated answer
  and `Elem` is the current element of the list being folded.
  ".
  case @ of
    {F, Acc, #[]}    -> Acc.
    {F, Acc, {H, T}} -> F {Foldr {F, Acc, T}, H}.
  end.
].

Length := [
  "
  @ = List

  Returns the length of `List`.
  ".
  Foldl {[{Acc, _} := @, Acc+1.], 0, @}.
].


Range := [
  "
  @ = {From, To}

  Returns a list of integers ranging from `From` (inclusive), to `To` (exclusive).
  ".
  {From, To} := @.
  Helper := [
    {N, Acc} := @.
    if N <= From
      then {N, Acc}.
      else Helper {N-1, {N, Acc}}.
    end.
  ].
  if To <= From
    then #[].
    else Helper {To-1, #[]}.
  end.
].

Nth := [
  "
  @ = {N, List}

  Returns the Nth element of `List`. The list must
  be long enough.
  ".
  {N, {H, T}} := @.
  if N <= 1
    then H.
    else Nth {N-1, T}.
  end.
].

Random_Choice := [
  "
  @ = List

  Returns a random element of `List`.
  ".
  Nth {Builtins:Random_Range {1, Length @ + 1}
      , @}.
].

Concat := [
  "
  @ = {List1, List2}

  Concatenates two lists.
  ".
  {L1, L2} := @.
  Helper := [
    {Elems_Left, Result} := @.
    case Elems_Left of
      #[]    -> Result.
      {H, T} -> Helper {T, {H, Result}}.
    end.
  ].
  Helper {Reverse L1, L2}.
].

Any := [
  "
  @ = {Func, List}

  Returns `yeah` if any of the elements of `List` pass the predicate function `Func`.
  ".
  {Func, List} := @.
  case List of
    #[]    -> nope.
    {H, T} -> if Func H then yeah. else Any {Func, T}. end.
  end.
].


All := [
  "
  @ = {Func, List}

  Returns `yeah` if all the elements of `List` pass the predicate function `Func`.
  ".
  {Func, List} := @.
  case List of
    #[]    -> yeah.
    {H, T} -> if Func H then All {Func, T}. else nope. end.
  end.
].


And := [
  "
  @ = List

  Returns `yeah` if all of the elements of `List` are truthy, `nope` otherwise.
  ".
  case @ of
    #[]    -> yeah.
    {H, T} -> if H then And T. else nope. end.
  end.
].

Or := [
  "
  @ = List

  Returns `yeah` if any of the elements of `List` are truthy, `nope` otherwise.
  ".
  case @ of
    #[]    -> nope.
    {H, T} -> if H then yeah. else Or T. end.
  end.
].


Member := [
  "
  @ = {Val, List}

  Returns `yeah` if `Val` is a member of the `List`, `nope` otherwise.
  ".
  {Val, List} := @.
  Any {[@ = Val.], List}.
].

Repeat := [
  "
  @ = {N, Elem}

  Return a list of `N` `Elem`s.
  ".
  {Times, Elem} := @.
  Helper := [
    {TimesLeft, Acc} := @.
    if TimesLeft <= 0
      then Acc.
      else Helper {TimesLeft-1, {Elem, Acc}}.
    end.
  ].
  Helper {Times, #[]}.
].

Remove := [
  "
  @ = {Elem, List}

  Return a list with all elements that are equal to `Elem` removed.
  ".
  {Elem, List} := @.
  #[E | E <- List, E != Elem].
].

Filter := [
  "
  @ = {Func, List}

  Return a list only with elements that pass the predicate function `Func`.
  ".
  {F, List} := @.
  #[E | E <- List, F E].
].

Separate := [
  "
  @ = {Func, List}.

  Returns a tuble of the form `{TrueBucket, FalseBucket}` where `TrueBucket`
  are a list of elements from `List` that are truthy according to `Func`, and
  where `FalseBucket` are a list of elements from `List` that are falsy according
  to `Func`.
  
  The elements of the buckets have no guaranteed ordering.
  ".
  {Func, List} := @.
  Helper := [
    case @ of
      {nil, TrueBucket, FalseBucket} -> {TrueBucket, FalseBucket}.
      {{H, T}, TrueBucket, FalseBucket} ->
        if Func H
          then Helper {T, {H, TrueBucket}, FalseBucket}.
          else Helper {T, TrueBucket, {H, FalseBucket}}.
        end.
    end.
  ].

  Helper {List, nil, nil}.
].

Zip := [
  "
  @ = {List1, List2}

  Zip two lists together. Returns a list of tuples.
  ".
  {L1, L2} := @.
  Helper := [
    case @ of
      {nil, _, Acc}             -> Acc.
      {_, nil, Acc}             -> Acc.
      {{H1, T1}, {H2, T2}, Acc} -> Helper {T1, T2, {{H1, H2}, Acc}}.
    end.
  ].
  Reverse (Helper {L1, L2, #[]}).
].

Zipwith := [
  "
  @ = {Func, L1, L2}

  Zip two lists together using the function `Func`.

  `Func` is called with the argument `{Elem1, Elem2}`, where `Elem1`
  is an element from `L1`, and `Elem2` is the corresponding element
  from `L2`.
  ".
  {F, L1, L2} := @.
  Helper := [
    case @ of
      {nil, _, Acc}             -> Acc.
      {_, nil, Acc}             -> Acc.
      {{H1, T1}, {H2, T2}, Acc} -> Helper {T1, T2, {F {H1, H2}, Acc}}.
    end.
  ].
  Reverse (Helper {L1, L2, #[]}).].

Partition_At := [
  "
  {N, List} := @

  Return a tuple of the form `{Seen, Unseen}`
  where `Seen` are elements before and including the `N`th element
  of `List`, and `Unseen` are the rest. `Seen` IS REVERSED. The reason
  `Seen` is reversed is that I want to implement other functions in terms
  of this function, and don't want unnecessary overhead.
  ".
  {N, List} := @.
  Helper := [
    case @ of
      {_, nil,    Seen}    -> {Seen,    nil}.
      {0, Unseen, Seen}    -> {Seen, Unseen}.
      {Left, {H, T}, Seen} ->
        Helper {Left-1, T, {H, Seen}}.
    end.
  ].
  if N > 0
    then Helper {N, List, nil}.
    else {#[], List}.
  end.
].

Take := [
  "
  @ = {N, List}

  Return the first `N` elements of `List`.
  ".
  Reverse (Car (Partition_At @)).
].

Drop := [
  "
  @ = {N, List}

  Drop the first `N` element off of `List`, and return the resulting list.
  ".
  Cdr (Partition_At @).
].


Takewhile := [
  "
  @ = {Func, List}

  Takes elements from `List` as long as they pass the predicate
  function `Func`, and returns the resulting list.

  It stops taking elements as soon as an element doesn't pass the
  predicate function `Func`.
  ".
  {F, List} := @.
  Helper := [
    case @ of
      {nil,    Acc} -> Acc.
      {{H, T}, Acc} ->
        if F H
          then Helper {T, {H, Acc}}.
          else Acc.
        end.
    end.
  ].
  Reverse (Helper {List, nil}).
].

Dropwhile :=  [
  "
  @ = {Func, List}

  Drops elements from `List` as long as they pass the predicate
  function `Func`, and returns the resulting list.

  It stops dropping elements as soon as an element doesn't pass the
  predicate function `Func`.
  ".
  case @ of
    {_, #[]}    -> #[].
    {F, {H, T}} ->
      if F H
        then Dropwhile {F, T}.
        else {H, T}.
      end.
  end.
].


ToTuple := [
  "
  @ = List

  Convert `List` into a tuple
  ".
  
  Helper := [
    case @ of
      {#[],    Acc} -> Acc.
      {{H, T}, Acc} -> Helper {T, Acc + {H}}.
    end.
  ].

  Helper {@, {}}.
].

Sortwith := [
  "
  @ = {Func, List}

  Sort `List` with the comparison function `Func`.

  `Func` should take an argument of the form `{Val_1, Val_2}`, and return
  `0` if they should be considered equal, `1` if `Val_1` should be
  considered 'higher', and `-1` if `Val_1` should be considered 'lower'.
  'higher' values goes to the end of the new list, 'lower' values go to
  the beginning.
  ".
  {Func, List} := @.
  (Tuples:ToList ~ Tuples:Sortwith) {Func, ToTuple List}.
].

Sort := [
  "
  @ = List

  Return a new version of `List`, sorted from low to high.
  ".
  (Tuples:ToList ~ Tuples:Sort ~ ToTuple) @.
].

ReverseSort := [
  "
  @ = List

  Return a new version of `List`, sorted from high to low.
  ".
  (Tuples:ToList ~ Tuples:ReverseSort ~ ToTuple) @.
].

Slice := [
  "
  @ = {Start, Stop, List}
    
  Returns a sublist of `List` starting at index `Start` (inclusive),
  ending at index `Stop` (exclusive).
  ".
  {Start, Stop, List} := @.
  Take {
    Stop-Start,
    Drop {Start-1, List}
  }.
].

Max := [
  "
  @ = List

  Returns the biggest element in `List`.
  ".
  case @ of
    #[]    -> Error "Max called with empty list".
    {H, T} -> Foldl {[
        {Acc, Elem} := @.
        if Acc > Elem
          then Acc.
          else Elem. 
        end.
      ], H, T}.
  end.
].

Min := [
  "
  @ = List

  Returns the smallest element in `List`.
  ".
  case @ of
    #[]    -> Error "Min called with empty list".
    {H, T} -> Foldl {[
        {Acc, Elem} := @.
        if Acc < Elem
          then Acc.
          else Elem. 
        end.
      ], H, T}.
  end.
].
